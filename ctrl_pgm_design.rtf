{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 Helvetica;\f2\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;\red42\green125\blue12;\red105\green19\blue113;\red81\green41\blue21;
\red155\green27\blue167;\red131\green131\blue131;\red59\green59\blue59;\red47\green33\blue233;\red177\green43\blue43;
\red36\green27\blue170;\red182\green35\blue35;\red65\green198\blue9;}
\margl1440\margr1440\vieww23760\viewh15580\viewkind0
\pard\tqr\tx3360\tx3640\tx3780\tx3920\tx4060\tx4200\tx4340\tx4480\tx4620\tx4760\tx4900\tx5040\tx5180\tx5320\tx5460\tx5600\tx5740\tx5880\tx6020\tx6160\tx6300\tx6440\tx6580\tx6720\tx6860\tx7000\tx7140\tx7280\tx7420\tx7560\tx7700\li3640\fi-3640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 [11:35] 	\cf2 *\cf0 	\cf2 Now talking on #avrlibc
\f1 \cf0 \

\f0 [11:35] 	\cf3 *\cf0 	calvino.freenode.net sets mode +n #avrlibc
\f1 \

\f0 [11:35] 	\cf3 *\cf0 	calvino.freenode.net sets mode +s #avrlibc
\f1 \

\f0 [11:35] 	\cf4 *	You have left channel #avrlibc ("Leaving")
\f1 \cf0 \

\f0 [11:35] 	\cf2 *\cf0 	\cf2 Now talking on #avr
\f1 \cf0 \

\f0 [11:35] 	\cf5 *\cf0 	\cf5 Topic for #avr\cf0  \cf5 is:  Start here: http://www.avrbeginners.net http://tom-itx.dyndns.org:81/~webpage/ http://www.avrfreaks.net  STAY AROUND IF YOU WANT AN ANSWER, TIMEZONES!
\f1 \cf0 \

\f0 [11:35] 	\cf5 *\cf0 	\cf5 Topic for #avr\cf0  \cf5 set by rue_mohr!~rue@h24-207-19-104.cst.dccnet.com\cf0  \cf5 at Tue Feb 14 05:54:39 2012
\f1 \cf0 \

\f0 [11:36] 	\cf6 Thetawaves_\cf7 	can anybody here explain to me how the avrlibc file gcrt1.S is turned into all the different crtsxxxx.o files
\f1 \cf0 \

\f0 [11:37] 	\cf2 *\cf0 	
\f2\b \cf2 cyanide 
\f0\b0 (cyanide@58.146.113.96) has joined #avr
\f1 \cf0 \

\f0 [11:37] 	\cf4 *\cf0 	\cf4 cyanide has quit (Changing host)
\f1 \cf0 \

\f0 [11:37] 	\cf2 *\cf0 	
\f2\b \cf2 cyanide 
\f0\b0 (cyanide@unaffiliated/cyanide) has joined #avr
\f1 \cf0 \

\f0 [11:37] 	\cf6 Thetawaves_\cf7 	there doesn't seem to be any chip specific sections in gctr1.S, so i'm confused as to why the compiled library is actually needed
\f1 \cf0 \

\f0 [11:38] 	\cf8 karlp\cf0 	because the different chips ahve different calling conventions, number of registers, etc
\f1 \

\f0 [11:38] 	\cf8 karlp\cf0 	wehther the PC is 2 bytes or 3,
\f1 \

\f0 [11:38] 	\cf8 karlp\cf0 	whether vectors are 1 byte or 2
\f1 \

\f0 [11:38] 	\cf6 Thetawaves_\cf7 	#ifdef __AVR_3_BYTE_PC__
\f1 \cf0 \

\f0 [11:39] 	\cf6 Thetawaves_\cf7 	thanks, makes more sense
\f1 \cf0 \

\f0 [11:40] 	\cf9 RikusW\cf0 	vectors is 1 or 2 words
\f1 \

\f0 [11:40] 	\cf6 Thetawaves_\cf7 	so what header file do i include with this .S file if i want to customize it and rebuild
\f1 \cf0 \

\f0 [11:41] 	\cf6 Thetawaves_\cf7 	how does that process work? would it be sufficient to just do -mmcu=xxx
\f1 \cf0 \

\f0 [11:42] 	\cf2 *\cf0 	
\f2\b \cf2 Santh 
\f0\b0 (~oryx@2a01:e35:2439:8660:69dd:a86f:814b:614f) has joined #avr
\f1 \cf0 \

\f0 [11:42] 	\cf4 *\cf0 	\cf4 janeUbuntu has quit (Ping timeout: 260 seconds)
\f1 \cf0 \

\f0 [11:43] 	\cf10 *	\cf9 RikusW\cf0  never tried it
\f1 \

\f0 [11:44] 	\cf2 *\cf0 	
\f2\b \cf2 janeUbuntu 
\f0\b0 (~jane@2001:3c8:c103:a001:983f:84ef:16f2:27d6) has joined #avr
\f1 \cf0 \

\f0 [11:45] 	
\f2\b \cf11 specing
\f0\b0 	Thetawaves_: have you found out that it sucks?
\f1 \cf0 \

\f0 [11:45] 	
\f2\b \cf11 specing
\f0\b0 	Thetawaves_: Like, it includes unnecessary code?
\f1 \cf0 \

\f0 [11:45] 	\cf8 specing\cf0 	I share that oppinion
\f1 \

\f0 [11:46] 	\cf8 karlp\cf0 	blah blah do everything in asm all the time blah blah hey specing? ;)
\f1 \

\f0 [11:46] 	\cf8 specing\cf0 	e.g. stack init when the chip sets it to RAMEND on reset
\f1 \

\f0 [11:46] 	\cf6 Thetawaves_\cf7 	well, i'm trying to generate 'loadable' objects, so the heap and stack are already setup, no vectors, etc
\f1 \cf0 \

\f0 [11:47] 	\cf8 specing\cf0 	If I had the time, I would have wrote a high level assembler
\f1 \

\f0 [11:47] 	\cf4 *\cf0 	\cf4 Steffanx has quit (Quit: Ik ga weg)
\f1 \cf0 \

\f0 [11:48] 	
\f2\b \cf11 specing
\f0\b0 	Thetawaves_: gcc -nostdlib ;)
\f1 \cf0 \

\f0 [11:48] 	\cf8 specing\cf0 	Also -Wl,--defsym -Wl,func=0x123  to define callback functions
\f1 \

\f0 [11:49] 	\cf6 Thetawaves_\cf7 	EXCELLENT
\f1 \cf0 \

\f0 [11:51] 	\cf10 *	\cf12 Thetawaves_\cf0  figuring out what this actually does
\f1 \

\f0 [11:54] 	\cf9 Erlkoenig\cf0 	defines a linker symbol...
\f1 \

\f0 [11:54] 	\cf6 Thetawaves_\cf7 	-nostdlib i mean
\f1 \cf0 \

\f0 [11:54] 	\cf9 Erlkoenig\cf0 	"Do not use the standard system startup files or libraries when linking.  No startup files and only the libraries you specify will  be passed to the linker, ... "
\f1 \

\f0 [11:57] 	\cf8 specing\cf0 	I know stuff :)
\f1 \

\f0 [11:58] 	\cf6 Thetawaves_\cf7 	so i've got only a few functions in this 'module', i define their addresses with --defsym, and call them using those addresses
\f1 \cf0 \

\f0 [11:58] 	\cf6 Thetawaves_\cf7 	and it would work the same going the other way
\f1 \cf0 \

\f0 [11:59] 	\cf8 specing\cf0 	yes
\f1 \

\f0 [11:59] 	\cf8 specing\cf0 	actually no
\f1 \

\f0 [11:59] 	\cf8 specing\cf0 	when you load the module, the hypervisor/control code/whatever starts executing from address 0x0 relative to the code
\f1 \

\f0 [12:00] 	\cf8 specing\cf0 	or rather, you have a header at the start of a module telling your hypervisor how long the .data, .bss and .text areas are
\f1 \

\f0 [12:00] 	\cf8 specing\cf0 	(so it knows where to put each of them)
\f1 \

\f0 [12:01] 	\cf6 Thetawaves_\cf7 	ahhhhh great!
\f1 \cf0 \

\f0 [12:01] 	\cf8 specing\cf0 	you only need the --defsym if you want to call "system calls" from the module
\f1 \

\f0 [12:01] 	\cf2 *\cf0 	
\f2\b \cf2 Essobi 
\f0\b0 (~Essobi@74-134-120-97.dhcp.insightbb.com) has joined #avr
\f1 \cf0 \

\f0 [12:02] 	\cf8 specing\cf0 	A slower but more reliable method would be to set the interrupt flag of some unused module
\f1 \

\f0 [12:02] 	\cf8 specing\cf0 	for example the SPM interrupt
\f1 \

\f0 [12:03] 	\cf8 specing\cf0 	and then push the address of the event loop onto the stack and doing a reti
\f1 \

\f0 [12:03] 	\cf6 Thetawaves_\cf7 	more reliable?
\f1 \cf0 \

\f0 [12:03] 	\cf2 *\cf0 	
\f2\b \cf2 Steffanx 
\f0\b0 (~Steffanx@ip4da726ae.direct-adsl.nl) has joined #avr
\f1 \cf0 \

\f0 [12:03] 	\cf8 specing\cf0 	the event loop can do a table lookup to find the function you want
\f1 \

\f0 [12:03] 	
\f2\b \cf11 specing
\f0\b0 	Thetawaves_: portable
\f1 \cf0 \

\f0 [12:04] 	\cf6 Thetawaves_\cf7 	i see what you mean
\f1 \cf0 \

\f0 [12:04] 	
\f2\b \cf11 specing
\f0\b0 	Thetawaves_: if you move the thing from an atmega to an attiny and you do a multiply somewhere in the middle of your syscalls, the resulting code will be bigger
\f1 \cf0 \

\f0 [12:04] 	\cf8 specing\cf0 	and so the --defsyms will be off
\f1 \

\f0 [12:05] 	\cf8 specing\cf0 	but it is much slower than just doing a rcall
\f1 \

\f0 [12:05] 	\cf8 specing\cf0 	_much_
\f1 \

\f0 [12:05] 	\cf8 specing\cf0 	4 cycles for the interrupt, another 4 to push the new address, 2 for the reti, about 10 for the lookup
\f1 \

\f0 [12:06] 	\cf8 specing\cf0 	oh and add a cycle to set the event flag and count how many events you have to check before reaching it
\f1 \

\f0 [12:06] 	\cf8 specing\cf0 	Its quite complex
\f1 \

\f0 [12:06] 	\cf8 specing\cf0 	first do the direct method
\f1 \

\f0 [12:10] 	\cf6 Thetawaves_\cf7 	alright, so if i've got the first few words of the module defining .data .bss and .text, and then a few words after that would be function pointer to the actual function that i want to call
\f1 \cf0 \

\f0 [12:10] 	\cf6 Thetawaves_\cf7 	init; run; what ever
\f1 \cf0 \

\f0 [12:13] 	\cf4 *\cf0 	\cf4 DanFrederiksen has quit ()
\f1 \cf0 \

\f0 [12:13] 	\cf8 specing\cf0 	The structure should be: <size of .data><size of .bss><size of .text><.data><.bss><.text><checksum>
\f1 \

\f0 [12:13] 	\cf4 *\cf0 	\cf4 tomatto has quit (Ping timeout: 252 seconds)
\f1 \cf0 \

\f0 [12:13] 	\cf4 *\cf0 	\cf4 kennyd has quit (Ping timeout: 276 seconds)
\f1 \cf0 \

\f0 [12:13] 	\cf2 *\cf0 	
\f2\b \cf2 tomatto 
\f0\b0 (~tomatto@114.51.broadband7.iol.cz) has joined #avr
\f1 \cf0 \

\f0 [12:13] 	\cf8 specing\cf0 	No, scratch <.bss>
\f1 \

\f0 [12:14] 	\cf8 specing\cf0 	its uninitialized
\f1 \

\f0 [12:14] 	\cf8 specing\cf0 	The structure should be: <size of .data><size of .bss><size of .text><.data><.text><checksum>
\f1 \

\f0 [12:15] 	\cf8 specing\cf0 	You can also give parameters to your os, like hints for the scheduler (e.g. this code is unimportant)
\f1 \

\f0 [12:15] 	\cf6 Thetawaves_\cf7 	so you claim just jump to the start of .text
\f1 \cf0 \

\f0 [12:16] 	\cf6 Thetawaves_\cf7 	and right it like a real C program
\f1 \cf0 \

\f0 [12:16] 	\cf6 Thetawaves_\cf7 	write
\f1 \cf0 \

\f0 [12:16] 	\cf6 Thetawaves_\cf7 	i have to include a symbol table in that structure
\f1 \cf0 \

\f0 [12:17] 	\cf6 Thetawaves_\cf7 	i can't just put main() at 0x0
\f1 \cf0 \

\f0 [12:17] 	\cf4 *\cf0 	\cf4 rbnielsen has quit (Quit: Leaving)
\f1 \cf0 \

\f0 [12:17] 	\cf4 *\cf0 	\cf4 RikusW has quit (Quit: Leaving.)
\f1 \cf0 \

\f0 [12:17] 	\cf2 *\cf0 	
\f2\b \cf2 kennyd 
\f0\b0 (~kennyd@93-136-80-180.adsl.net.t-com.hr) has joined #avr
\f1 \cf0 \

\f0 [12:17] 	\cf8 specing\cf0 	indeed
\f1 \

\f0 [12:18] 	\cf8 specing\cf0 	<size of .data>... <- header}